---
tags: []
projects: []
---
:spring_version: 5.0.0.RC3
:spring_boot_version: 2.0.0.BUILD-SNAPSHOT
:SpringApplication: http://docs.spring.io/spring-boot/docs/{spring_boot_version}/api/org/springframework/boot/SpringApplication.html
:toc:
:icons: font
:source-highlighter: prettify
:project_id: draft-gs-template

This guide walks you through the process of creating a RESTful web service with Spring
WebFlux (new as of version 5). This example uses the annotations that have become popular
with Spring developers. It also consumes another service to get its data.

NOTE: This guide shows the annotation-based way to use Spring WebFlux. You can also
http://aLinkToSomething[use a functional approach with WebFlux].
// TODO - need to get the actual address.

== What You'll Build

Youâ€™ll build a RESTful web service with Spring Webflux annotations and get the data for
your service by consuming another service. The source service produces quotations about a
book (authored by one of Spring's developers). You'll be able to see output at:

[source]
http://localhost:8080/randomquotation

and

[source]
http://localhost:8080/quotations

== What You'll Need

:java_version: 1.8
include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/prereq_editor_jdk_buildtools.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/how_to_complete_this_guide.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-gradle.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-maven.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-sts.adoc[]

[[initial]]
== Create Two Data Classes

To handle the data we get from the quotation service that feeds data to our service, we
need to have a data model. In this case, it needs to have two POJO classes, one for
quotations and one for the value of the quotation (really, the actual quotation). The
following listing shows the Quotation class:

`src/main/java/quotation/Quotation.java`
[source,java]
----
include::complete/src/main/java/quotation/Quotation.java[]
----

The Quotation class relies on another class to hold the value of each quotation. The
following listing shows that class, called Value:

`src/main/java/quotation/Value.java`
[source,java]
----
include::complete/src/main/java/quotation/Value.java[]
----

Together, the Quotation and Value classes give us a data model that we can now use with
our REST controller.

== Create a REST Controller

In this application, we use a REST Controller to handle two routes ("/randomquotation"
and "/quotations"). The first route ("/randomquotation") takes no arguments. The sedcond
route ("/quotatoions") can take two arguments, to specify which quotation to start with
and how many quotations to return. The following listing shows our REST controller:

`src/main/java/quotation/QuotationController.java`
[source,java]
----
include::complete/src/main/java/quotation/QuotationController.java[]
----

The router listens for traffic on the `/randomquotation` and `quotations` paths and
returns one or more quotations to the browser.

To get a random quotation, we call a private helper method to get the value from the
upstream service (the quotation generator) and store it in a `Mono` object. Thanks to
WebFlux's support for Project Reactor, all we have to do is return the Mono object, and
the content (as JSON, because that's what our domain model provides) goes to the browser.
We can avoid writing much code, because the framework does nearly all the work.

To get a number of quotations in a single request, we let visitors to our web site
specify  both how many quotations to get and the ID number of the starting quotation. We
have to  provide some logic for what to do if the visitor specifies nonsense values. We
need to  check only for valid integers, because, if someone provides an argument that
can't be  recognized as an integer, the framework catches it for us. Then we need to
provide the  number of quotations the visitor asked for, starting at the specified
number, wrapping  around the end of the list to number 1 if we must. Because we want to
hold multiple  results, we use a `Flux` object rather than a `Mono` object. Note the use
of `Mono.flux()` (in the line `Flux<Quotation> flux = firstMono.flux();`). That method
converts our first `Mono` object into a `Flux` object, which is the object we'll return.
For each quotation, we get the quotation from our data source and add it to the `Flux`
object. Again, all we need to do is return the `Flux` object. The framework knows what to
do with a Flux object and delivers the content to the browser for us.

TIP: `Mono` handles 0 or 1 items. `Flux` handles 0 to n objects.

The helper method (`getQuotation`) uses a WebClient object to get the quotation from the
upstream quotation service and turn into a `Mono` object that we can then use in our
other methods.

TIP: WebClient can be used to communicate with non-reactive, blocking services, as we do
here.

== Make the Application Executable

Although it is possible to package this service as a traditional
link:/understanding/WAR[WAR] file for deployment to an external application server,
the simpler approach demonstrated below creates a standalone application. You package
everything in a single, executable JAR file, driven by a good old Java `main()` method.
Along the way, you use Reactive Spring's support for embedding the Netty server as the
HTTP runtime, instead of deploying to an external instance.

`src/main/java/hello/Application.java`
[source,java]
----
include::complete/src/main/java/hello/Application.java[]
----

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/spring-boot-application.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/build_an_executable_jar_subhead.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/build_an_executable_jar_with_both.adoc[]

Logging output is displayed. The service should be up and running within a few seconds.

Once the service has started, you'll see a line that reads:

`>> result = Hello, Spring!`

That line comes from the reactive content being consumed by the WebClient. Naturally,
you can find something more interesting to do with your output than put it in System.out.

== Test the Application

Now that the application is running, you can test it. To start with, you can open a
browser and go to `http://localhost:8080/hello` and see, "Hello, Spring!" For this guide,
we also created a test class to get you started on testing with the WebTestClient class.

`src/test/java/hello/GreetingRouterTest.java`
[source,java]
----
include::complete/src/test/java/hello/GreetingRouterTest.java[]
----

== Summary

Congratulations! You have developed a Reactive Spring application that includes a
WebClient to consume a RESTful service!

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/footer.adoc[]
